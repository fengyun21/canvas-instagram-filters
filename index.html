<meta charset='utf-8'>
<style>body {
  box-shadow: inset 0 3px 0 0 #242331;
  color: #333;
  font-family: "Roboto Draft", "Roboto", -apple-system, BlinkMacSystemFont, "Segoe UI", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif;
  font-size: 14px;
  font-weight: 400;
  line-height: 20px;
  margin: 0;
  padding-bottom: 40px;
  padding-top: 24px
}

/* body:before { */
/*   position: absolute; */
/*   content: ""; */
/*   background-size: 4px 4px; */
/*   background-image: linear-gradient(0deg, transparent, red 1px, transparent 1px, transparent 4px), linear-gradient(90deg, transparent, red 1px, transparent 1px, transparent 4px); */
/*   left: 0; */
/*   right: 0; */
/*   top: 0; */
/*   height: 99999px; */
/*   z-index: 100000; */
/*   mix-blend-mode: difference; */
/*   pointer-events: none; */
/* } */

p, div, section, main, ul, ol, dl, h1, h2, h3, h4, h5, h6, pre code, blockquote, iframe {
  display: block;
  margin-left: auto;
  margin-right: auto;
  max-width: 510px;
  padding-left: 16px;
  padding-right: 16px;
}

iframe {
  border-radius: 2px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
  padding: 0;
  margin: 16px auto 32px;
}

h1, h2, h3 {
  -webkit-font-smoothing: antialiased;
	-moz-osx-font-smoothing: grayscale;
}

h1, h2, h3, h4, h5, h6 {
  color: #242331;
}

ol, ul {
  line-height: 28px;
  margin-top: 0;
  margin-bottom: 8px;
}

li {
  display: flex;
  list-style: none;
}

li:before {
  display: inline-block;
  margin-left: -16px;
  opacity: 0.54;
  text-align: right;
  padding-right: 12px;
  padding-left: 12px;
  width: 16px;
}

ul > li:before {
  content: "•";
}

ol {
  counter-reset: ordered
}

ol > li:before {
  content: counter(ordered) ".";
  counter-increment: ordered;
}

li p:first-child {
  margin-top: 0;
}

li p {
  padding: 0 0 16px;
}

h1 {
  font-size: 34px;
  font-weight: 500;
  line-height: 48px;
  margin: 32px auto 56px;
}

h2 {
  font-size: 24px;
  font-weight: 500;
  line-height: 44px;
  margin-top: 24px;
  margin-bottom: 8px;
}

h3 {
  font-size: 20px;
  font-weight: 600;
  line-height: 44px;
  margin-top: 24px;
}

h4 {
  font-size: 16px;
  font-weight: 400;
  line-height: 32px;
}

h5, h6 {
  font-size: 14px;
  font-weight: 600;
  line-height: 32px;
}

p {
  line-height: 28px;
  margin: 0 auto;
  padding: 12px 16px 24px;
  hyphens: auto;
  -webkit-hyphens: auto;
}

p + p {
  padding-top: 0;
}

code {
  color: #c7254e;
  font-size: 12px;
  padding: 2px;
  background-color: #f9f2f4;
}

pre {
  background: #242331;
  padding: 38px 16px;
  line-height: 24px;
  margin: 20px 0 36px;
  overflow: auto;
}

pre code {
  background: transparent;
  color: #ECECF6;
  border-radius: 0;
  font-size: 100%;
  font-family: 'Inconsolata', "Lucida Console", Monaco, monospace;
  padding: 0;
}

a {
  color: inherit;
  transition: 0.3s all;
}

a:hover,
a:focus {
  color: #44f;
  transition: 0.1s all;
}

blockquote {
  border-left: 8px solid #ccc;
  margin: 40px auto;
  quotes: "\201C""\201D""\2018""\2019";
  font-style: italic;
  font-family: 'Georgia', serif;
  font-size: 110%;
  color: #666;
  padding: 8px 0 1px 12px;
}

hr {
  border: 0;
  border-bottom: 1px dotted #ccc;
  margin: 48px 0;
}

/**
 * Tomorrow Night Theme
 * http://jmblog.github.com/color-themes-for-google-code-highlightjs
 * Original theme - https://github.com/chriskempson/tomorrow-theme
 * http://jmblog.github.com/color-themes-for-google-code-highlightjs
 */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
  color: #969896;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
  color: #cc6666;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
  color: #de935f;
}

/* Tomorrow Yellow */
.hljs-attribute {
  color: #f0c674;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
  color: #b5bd68;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
  color: #81a2be;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
  color: #b294bb;
}

.hljs {
  display: block;
  overflow-x: auto;
  background: #1d1f21;
  color: #c5c8c6;
  padding: 0.5em;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}
</style><h1 id="color-burn-multiply-and-other-blend-modes-in-html5-canvas">Color Burn, Multiply, and other Blend Modes in HTML5 Canvas</h1>
<p><a href="https://www.instagram.com/">Instagram</a> made us all fall in love with
image filters. A well-chosen filter can augment the best parts of a
photo, or soften undesirable qualities.</p>
<p>On a recent project I was charged with implementing similar image filters
for a JavaScript application that leans on HTML5 canvas.</p>
<p>So began my journey down the beautiful rabbit hole that is pixel
manipulation.</p>
<h2 id="prior-art">Prior Art</h2>
<p>Late last year
<a href="https://github.com/una/CSSgram">Una Kravets gave us Instagram filters in CSS</a>. The
project is an excellent example of how powerful CSS has become.</p>
<p>In brief, modern CSS allows one to apply a blending mode directly to a
CSS element:</p>
<iframe src="http://codepen.io/nhunzaker/full/LNNmLm/" width="100%" height="390" frameborder="0"></iframe>

<p>Specifically, modern CSS grants access to
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode"><code>mix-blend-mode</code></a>. This
CSS property exposes the full gamut of blending modes one would expect
from a graphical image editor.</p>
<h2 id="bringing-blend-modes-to-html5-canvas">Bringing Blend Modes to HTML5 Canvas</h2>
<blockquote>
<p>“The future is already here — it’s just not very evenly distributed.”</p>
<p>William Gibson</p>
</blockquote>
<p>2D context canvas already supports these blend modes! However they
do not have universal browser support. In order to achieve full
browser support, the canvas image data must be manipulated
directly. Fortunately, the browser gives us really good tools for
that.</p>
<h2 id="setting-things-up">Setting things up</h2>
<p>We need to set up a basic environment before we can begin. We’ll load
an image, then render the scene once it has finished loading:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"canvas"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"500"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"500"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-keyword">var</span> photo    = <span class="hljs-keyword">new</span> Image();
  <span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'canvas'</span>);
  <span class="hljs-keyword">var</span> ctx    = canvas.getContext(<span class="hljs-string">'2d'</span>);

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// Scale so that the image fills the container</span>
    <span class="hljs-keyword">var</span> width  = <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">700</span>, <span class="hljs-built_in">window</span>.innerWidth)
    <span class="hljs-keyword">var</span> scale  = width / photo.naturalWidth;
    <span class="hljs-keyword">var</span> height = photo.naturalHeight * scale

    canvas.width  = width
    canvas.height = height

    ctx.drawImage(photo, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)
  }

  photo.onload = render;
  photo.crossOrigin = <span class="hljs-string">"Anonymous"</span>;
  photo.src = <span class="hljs-string">"http://code.viget.com/artifacts/about-3.jpg"</span>;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>Essentially, create a <code>render</code> function that draws an image, then call
it when the image finishes loading.</p>
<iframe src="http://codepen.io/nhunzaker/full/xVVjJj/" width="100%" height="390" frameborder="0"></iframe>

<p>This paints the image. However
<a href="https://github.com/una/CSSgram/blob/master/source/scss/toaster.scss">Ina’s implementation of Toaster</a>,
there is a radial gradient on top.</p>
<p>This is provided by the 2D canvas API:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toasterGradient</span> (<span class="hljs-params">width, height</span>) </span>{
  <span class="hljs-keyword">var</span> texture = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'canvas'</span>);
  <span class="hljs-keyword">var</span> ctx = texture.getContext(<span class="hljs-string">'2d'</span>);

  texture.width = width;
  texture.height = height;

  <span class="hljs-comment">// Fill a Radial Gradient</span>
  <span class="hljs-comment">// https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/createRadialGradient</span>
  <span class="hljs-keyword">var</span> gradient = ctx.createRadialGradient(width / <span class="hljs-number">2</span>, height / <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, width / <span class="hljs-number">2</span>, height / <span class="hljs-number">2</span>, width * <span class="hljs-number">0.6</span>);

  gradient.addColorStop(<span class="hljs-number">0</span>, <span class="hljs-string">"#804e0f"</span>);
  gradient.addColorStop(<span class="hljs-number">1</span>, <span class="hljs-string">"#3b003b"</span>);

  ctx.fillStyle = gradient;
  ctx.fillRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);

  <span class="hljs-keyword">return</span> ctx
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// ... prior code</span>

  <span class="hljs-keyword">var</span> gradient = toasterGradient(width, height)

  ctx.drawImage(gradient.canvas, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
}
</code></pre>
<p>We’re getting there. However this leaves us with an opaque
purple-orange gradient covering our image.</p>
<iframe src="http://codepen.io/nhunzaker/full/vGGVYo/" width="100%"
height="390" frameborder="0"></iframe>

<p>Not ideal. We need to blend the pixels in the gradient with the
background. That means enumerating over the pixel data Canvas gives us
a great way to do that with <code>context.getImageData</code>.</p>
<h2 id="context-getimagedata">context.getImageData</h2>
<p><code>context.getImageData</code> grabs a box of pixels from the canvas and
returns an <code>ImageData</code> object. <code>ImageData</code> provides <code>width</code>,
<code>height</code>, and <code>data</code> properties. We only care about the <code>data</code>
field:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">blend</span> (<span class="hljs-params">background, foreground, width, height, transform</span>) </span>{
  <span class="hljs-keyword">var</span> bottom = background.getImageData(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);
  <span class="hljs-keyword">var</span> top    = foreground.getImageData(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, size = top.data.length; i &lt; size; i += <span class="hljs-number">4</span>) {
    <span class="hljs-comment">// red</span>
    top.data[i+<span class="hljs-number">0</span>] = transform(bottom.data[i+<span class="hljs-number">0</span>], top.data[i+<span class="hljs-number">0</span>]);
    <span class="hljs-comment">// green</span>
    top.data[i+<span class="hljs-number">1</span>] = transform(bottom.data[i+<span class="hljs-number">1</span>], top.data[i+<span class="hljs-number">1</span>]);
    <span class="hljs-comment">// blue</span>
    top.data[i+<span class="hljs-number">2</span>] = transform(bottom.data[i+<span class="hljs-number">2</span>], top.data[i+<span class="hljs-number">2</span>]);
    <span class="hljs-comment">// the fourth slot is alpha. We don't need that (so skip by 4)</span>
  }

  <span class="hljs-keyword">return</span> top
}
</code></pre>
<p>Cool. Enumerate over ever pixel of the gradient (the foreground) and
replace the pixel with the result of a given transformation function.</p>
<p>So what do I mean by transformation function? I mean a blending mode
transformation. This is not propriety knowledge, <a href="https://en.wikipedia.org/wiki/Blend_modes">Wikipedia contains a
wealth of formulas for a number of blend modes</a>.</p>
<h2 id="implementing-the-screen-blend-mode">Implementing the screen blend mode</h2>
<p><a href="https://github.com/una/CSSgram/blob/master/source/css/toaster.css#L32">According to CSSGram</a>,
we need the “screen” blend mode for Toaster. This formula is:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// https://en.wikipedia.org/wiki/Blend_modes#Screen</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">screen</span> (<span class="hljs-params">bottomPixel, topPixel</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> - (<span class="hljs-number">1</span> - bottomPixel) * (<span class="hljs-number">1</span> - topPixel)
}
</code></pre>
<p>Since <code>getImageData</code> returns color values between 0 and 255, we need
to make a minor tweak:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// https://en.wikipedia.org/wiki/Blend_modes#Screen</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">screen</span> (<span class="hljs-params">a, b</span>) </span>{
  bottomPixel /= <span class="hljs-number">255</span>
  topPixel    /= <span class="hljs-number">255</span>

  <span class="hljs-keyword">return</span> <span class="hljs-number">255</span> * (<span class="hljs-number">1</span> - (<span class="hljs-number">1</span> - topPixel) * (<span class="hljs-number">1</span> - bottomPixel))
}
</code></pre>
<p>Finally, let’s invoke the <code>blend</code> function with this transformation:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// ...prior code</span>
  <span class="hljs-keyword">var</span> screen = blend(ctx, gradient, width, height, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">bottomPixel, topPixel</span>) </span>{
    bottomPixel /= <span class="hljs-number">255</span>
    topPixel    /= <span class="hljs-number">255</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">255</span> * (<span class="hljs-number">1</span> - (<span class="hljs-number">1</span> - topPixel) * (<span class="hljs-number">1</span> - bottomPixel))
  })

  <span class="hljs-comment">// replace `ctx.drawImage(gradient.canvas, 0, 0)` with this:</span>
  ctx.putImageData(screen, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)
}
</code></pre>
<p>Nice! This performs the blending we want.</p>
<iframe src="http://codepen.io/nhunzaker/full/jqqeEm/" width="100%"
height="390" frameborder="0"></iframe>

<h2 id="why-is-it-so-washed-out-">Why is it so washed out?</h2>
<p>We’ve neglected an important component: <a href="https://github.com/una/CSSgram/blob/master/source/scss/toaster.scss#L11">Toaster manipulates contrast and
brightness using the CSS <code>filter</code> property</a>.</p>
<p>Brightness and contrast are a little tricker, however the
techniques are well established. The internet is a deep ocean of free
information. Furtunately for us, <a href="http://www.createjs.com/docs/easeljs/files/easeljs_filters_ColorMatrixFilter.js.html#l41">the HTML5 drawing
library EaselJS has already solved this problem for us</a>. Color
matrices provide a way to manipulate the brightness, color, contrast,
and saturation of an image.</p>
<h2 id="using-color-matrices">Using Color Matrices</h2>
<p>For the sake of keeping focused, I’ve extracted the color matrix
algorithm from EaselJS for the purposes of this blog post, I won’t
make you wade through matrix multiplication. However feel free to
checkout
<a href="https://gist.github.com/nhunzaker/79c599d367b168819c11">the source code</a>
if you are curious</p>
<p>After we pull in a color matrix transformation library, manipulating brightness and contrast is a matter of sending
parameters into a color matrix:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"color-matrix.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">
  <span class="hljs-comment">//... prior code</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">//...prior code</span>
    <span class="hljs-keyword">var</span> colorCorrected = colorMatrix(screen, { contrast: <span class="hljs-number">30</span>, brightness: <span class="hljs-number">-30</span> })

    <span class="hljs-comment">// Replace `ctx.putImageData(screen, 0, 0)` with:</span>
    ctx.putImageData(colorCorrected, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>The specific brightness and contrast parameters are different, however
the effect is virtually the same. Beautiful:</p>
<iframe src="http://codepen.io/nhunzaker/full/oxxaXO/" width="100%"
height="390" frameborder="0"></iframe>

<h2 id="we-made-it">We made it</h2>
<p>A quick diff from Photoshop also shows us that we hit the mark pretty
closely:</p>
<div>
  <img src="https://cloud.githubusercontent.com/assets/590904/13647908/41ef37c0-e604-11e5-8e1d-1f47ee77a70b.png" style="max-width: 100%; display: block;"/>
</div>

<p>Darker pixels means a closer match.</p>
<p>Implementing blend modes such as <code>screen</code>, <code>multiply</code> and <code>color-burn</code>
are totally achievable; it just takes a little more work. The result
is fantastic, beautiful photography within 2D context canvas.</p>

